import { __read, __spread } from '../../_virtual/_tslib.js';
import { useRef, useReducer, useEffect, useCallback, useMemo } from 'react';
import { useCompare } from '../use-compare/index.js';

/**
 * Returns a timer that works inside the React lifecycle.
 *
 * @param length - The total length of the timer (in milliseconds).
 * @param tick - The interval at which to update the timer (in milliseconds).
 */
function useTimer(options) {
    var length = options.length, _a = options.tick, tick = _a === void 0 ? 1000 : _a, _b = options.autoStart, autoStart = _b === void 0 ? false : _b;
    var remaining = useRef(length);
    var isRunning = useRef(autoStart);
    var isStarted = useRef(autoStart);
    var lengthRef = useRef(length);
    var tickRef = useRef(tick);
    var _c = __read(useReducer(function (x) { return x + 1; }, 0), 2), key = _c[0], forceUpdate = _c[1];
    // Save the latest `tick` value.
    useEffect(function () {
        tickRef.current = tick;
    }, [tick]);
    // Save the latest `length` value.
    useEffect(function () {
        lengthRef.current = length;
    }, [length]);
    // Build timer functionality callbacks.
    var start = useCallback(function () {
        if (!isRunning.current && !isStarted.current) {
            isRunning.current = true;
            isStarted.current = true;
            forceUpdate();
        }
    }, []);
    var pause = useCallback(function () {
        if (isRunning.current) {
            isRunning.current = false;
            forceUpdate();
        }
    }, []);
    var resume = useCallback(function () {
        if (!isRunning.current && isStarted.current) {
            isRunning.current = true;
            forceUpdate();
        }
    }, []);
    var reset = useCallback(function (newLength, newTick) {
        if (newTick)
            tickRef.current = newTick;
        if (newLength)
            lengthRef.current = newLength;
        if (isRunning.current)
            isRunning.current = false;
        remaining.current = newLength || lengthRef.current;
        isStarted.current = false;
        forceUpdate();
    }, []);
    // Update the timer.
    useEffect(function () {
        if (isRunning.current && remaining.current > 0) {
            var id_1 = setTimeout(function () {
                remaining.current -= tickRef.current;
                forceUpdate();
            }, tickRef.current);
            return function () { return clearTimeout(id_1); };
        }
        if (isRunning.current && remaining.current === 0) {
            isRunning.current = false;
            forceUpdate();
        }
        if (isRunning.current && remaining.current < 0) {
            remaining.current = 0;
            isRunning.current = false;
            forceUpdate();
        }
        return undefined;
    }, [key]);
    return useMemo(function () { return ({
        start: start,
        pause: pause,
        resume: resume,
        reset: reset,
        getRemaining: function () { return remaining.current; },
        getLength: function () { return lengthRef.current; },
        isRunning: function () { return isRunning.current; },
        key: key,
    }); }, [start, pause, resume, reset, key]);
}
/**
 * Execute an effect if the supplied timer ticks.
 *
 * @param timer - The `TimerHook` object to base effects from.
 * @param effect - Imperative function that can return a cleanup function.
 * @param deps - If present, effect will only activate if the values in the list change.
 */
function useTimerEffect(timer, effect, deps) {
    if (deps === void 0) { deps = []; }
    var didTimerChange = useCompare(timer.getRemaining());
    var savedCallback = useRef(effect);
    useEffect(function () {
        savedCallback.current = effect;
    }, [effect]);
    useEffect(function () {
        if (timer.isRunning() && didTimerChange && timer.getRemaining() > 0) {
            return savedCallback.current();
        }
        return undefined;
    }, __spread([timer.key], deps));
}
/**
 * Execute an effect if the supplied timer completes.
 *
 * @param timer - The `TimerHook` object to base effects from.
 * @param effect - Imperative function that can return a cleanup function.
 * @param deps - If present, effect will only activate if the values in the list change.
 */
function useTimerComplete(timer, effect, deps) {
    if (deps === void 0) { deps = []; }
    var didTimerChange = useCompare(timer.getRemaining());
    var savedCallback = useRef(effect);
    useEffect(function () {
        savedCallback.current = effect;
    }, [effect]);
    useEffect(function () {
        if (didTimerChange && timer.getRemaining() <= 0) {
            return savedCallback.current();
        }
        return undefined;
    }, __spread([timer.key], deps));
}

export { useTimer, useTimerComplete, useTimerEffect };
//# sourceMappingURL=index.js.map
