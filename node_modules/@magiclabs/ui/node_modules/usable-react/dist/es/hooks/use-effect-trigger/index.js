import { __read, __spread } from '../../_virtual/_tslib.js';
import { useReducer, useRef, useEffect } from 'react';
import { useCompare } from '../use-compare/index.js';

/**
 * Exactly like `useEffect`, except that it returns a memoized function to
 * trigger the effect in question. The effect only executes when the trigger
 * updates regardless of the given `deps`.
 *
 * A few use-cases for this hook include:
 *
 * 1. Deferring an effect to the next render tick.
 * 2. Sequencing asynchronous effects.
 * 3. Executing an effect after marshalling arbitrary state/data required for
 *    the effect to proceed.
 */
function useEffectTrigger(effect, deps) {
    if (deps === void 0) { deps = []; }
    var _a = __read(useReducer(function (x) { return x + 1; }, 0), 2), i = _a[0], trigger = _a[1];
    var didTriggerUpdate = useCompare(i);
    var savedCallback = useRef(effect);
    useEffect(function () {
        savedCallback.current = effect;
    }, [effect]);
    useEffect(function () {
        if (didTriggerUpdate) {
            return savedCallback.current();
        }
        return undefined;
    }, __spread([i], deps));
    return trigger;
}

export { useEffectTrigger };
//# sourceMappingURL=index.js.map
