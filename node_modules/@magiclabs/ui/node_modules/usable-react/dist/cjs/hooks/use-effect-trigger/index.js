'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../_virtual/_tslib.js');
var React = require('react');
var index = require('../use-compare/index.js');

/**
 * Exactly like `useEffect`, except that it returns a memoized function to
 * trigger the effect in question. The effect only executes when the trigger
 * updates regardless of the given `deps`.
 *
 * A few use-cases for this hook include:
 *
 * 1. Deferring an effect to the next render tick.
 * 2. Sequencing asynchronous effects.
 * 3. Executing an effect after marshalling arbitrary state/data required for
 *    the effect to proceed.
 */
function useEffectTrigger(effect, deps) {
    if (deps === void 0) { deps = []; }
    var _a = _tslib.__read(React.useReducer(function (x) { return x + 1; }, 0), 2), i = _a[0], trigger = _a[1];
    var didTriggerUpdate = index.useCompare(i);
    var savedCallback = React.useRef(effect);
    React.useEffect(function () {
        savedCallback.current = effect;
    }, [effect]);
    React.useEffect(function () {
        if (didTriggerUpdate) {
            return savedCallback.current();
        }
        return undefined;
    }, _tslib.__spread([i], deps));
    return trigger;
}

exports.useEffectTrigger = useEffectTrigger;
//# sourceMappingURL=index.js.map
