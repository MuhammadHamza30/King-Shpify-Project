'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../_virtual/_tslib.js');
var React = require('react');
var index = require('../use-compare/index.js');

/**
 * Returns a timer that works inside the React lifecycle.
 *
 * @param length - The total length of the timer (in milliseconds).
 * @param tick - The interval at which to update the timer (in milliseconds).
 */
function useTimer(options) {
    var length = options.length, _a = options.tick, tick = _a === void 0 ? 1000 : _a, _b = options.autoStart, autoStart = _b === void 0 ? false : _b;
    var remaining = React.useRef(length);
    var isRunning = React.useRef(autoStart);
    var isStarted = React.useRef(autoStart);
    var lengthRef = React.useRef(length);
    var tickRef = React.useRef(tick);
    var _c = _tslib.__read(React.useReducer(function (x) { return x + 1; }, 0), 2), key = _c[0], forceUpdate = _c[1];
    // Save the latest `tick` value.
    React.useEffect(function () {
        tickRef.current = tick;
    }, [tick]);
    // Save the latest `length` value.
    React.useEffect(function () {
        lengthRef.current = length;
    }, [length]);
    // Build timer functionality callbacks.
    var start = React.useCallback(function () {
        if (!isRunning.current && !isStarted.current) {
            isRunning.current = true;
            isStarted.current = true;
            forceUpdate();
        }
    }, []);
    var pause = React.useCallback(function () {
        if (isRunning.current) {
            isRunning.current = false;
            forceUpdate();
        }
    }, []);
    var resume = React.useCallback(function () {
        if (!isRunning.current && isStarted.current) {
            isRunning.current = true;
            forceUpdate();
        }
    }, []);
    var reset = React.useCallback(function (newLength, newTick) {
        if (newTick)
            tickRef.current = newTick;
        if (newLength)
            lengthRef.current = newLength;
        if (isRunning.current)
            isRunning.current = false;
        remaining.current = newLength || lengthRef.current;
        isStarted.current = false;
        forceUpdate();
    }, []);
    // Update the timer.
    React.useEffect(function () {
        if (isRunning.current && remaining.current > 0) {
            var id_1 = setTimeout(function () {
                remaining.current -= tickRef.current;
                forceUpdate();
            }, tickRef.current);
            return function () { return clearTimeout(id_1); };
        }
        if (isRunning.current && remaining.current === 0) {
            isRunning.current = false;
            forceUpdate();
        }
        if (isRunning.current && remaining.current < 0) {
            remaining.current = 0;
            isRunning.current = false;
            forceUpdate();
        }
        return undefined;
    }, [key]);
    return React.useMemo(function () { return ({
        start: start,
        pause: pause,
        resume: resume,
        reset: reset,
        getRemaining: function () { return remaining.current; },
        getLength: function () { return lengthRef.current; },
        isRunning: function () { return isRunning.current; },
        key: key,
    }); }, [start, pause, resume, reset, key]);
}
/**
 * Execute an effect if the supplied timer ticks.
 *
 * @param timer - The `TimerHook` object to base effects from.
 * @param effect - Imperative function that can return a cleanup function.
 * @param deps - If present, effect will only activate if the values in the list change.
 */
function useTimerEffect(timer, effect, deps) {
    if (deps === void 0) { deps = []; }
    var didTimerChange = index.useCompare(timer.getRemaining());
    var savedCallback = React.useRef(effect);
    React.useEffect(function () {
        savedCallback.current = effect;
    }, [effect]);
    React.useEffect(function () {
        if (timer.isRunning() && didTimerChange && timer.getRemaining() > 0) {
            return savedCallback.current();
        }
        return undefined;
    }, _tslib.__spread([timer.key], deps));
}
/**
 * Execute an effect if the supplied timer completes.
 *
 * @param timer - The `TimerHook` object to base effects from.
 * @param effect - Imperative function that can return a cleanup function.
 * @param deps - If present, effect will only activate if the values in the list change.
 */
function useTimerComplete(timer, effect, deps) {
    if (deps === void 0) { deps = []; }
    var didTimerChange = index.useCompare(timer.getRemaining());
    var savedCallback = React.useRef(effect);
    React.useEffect(function () {
        savedCallback.current = effect;
    }, [effect]);
    React.useEffect(function () {
        if (didTimerChange && timer.getRemaining() <= 0) {
            return savedCallback.current();
        }
        return undefined;
    }, _tslib.__spread([timer.key], deps));
}

exports.useTimer = useTimer;
exports.useTimerComplete = useTimerComplete;
exports.useTimerEffect = useTimerEffect;
//# sourceMappingURL=index.js.map
