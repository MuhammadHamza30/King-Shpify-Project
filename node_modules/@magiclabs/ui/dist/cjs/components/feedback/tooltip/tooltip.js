'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../../_virtual/_tslib.js');
var React = require('react');
var forwardRefWrapper = require('../../../libs/forward-ref-wrapper.js');
var mergeProps = require('../../../libs/merge-props.js');
var exceptions = require('../../../libs/exceptions.js');
require('clsx');
var popover = require('../../layout/popover/popover.js');
require('usable-react');
require('@seznam/compose-react-refs');
require('react-aria');
require('blueimp-md5');
require('color');
require('@artsy/fresnel');
require('../../theme-provider/theme-provider.js');
require('../../theme-provider/theme-head.js');
require('framer-motion');
require('react-dom');
require('@react-aria/ssr');
require('watch-resize');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

/* eslint-disable no-nested-ternary */
const TooltipBase = /* @__PURE__ */ forwardRefWrapper.forwardRefWrapper('Tooltip', {
    delay: 0,
    arrow: true,
    waitForPointerExit: true,
}, (props, externalRef) => {
    var _a, _b;
    const { children, in: inProp, delay, waitForPointerExit } = props, otherProps = _tslib.__rest(props, ["children", "in", "delay", "waitForPointerExit"]);
    const [shouldShow, setShouldShow] = React.useState(inProp);
    const [isMouseOverTooltip, setIsMouseOverTooltip] = React.useState(false);
    const showDelay = typeof delay === 'number' ? delay : (delay === null || delay === void 0 ? void 0 : delay.show) || 0;
    const hideDelay = typeof delay === 'number' ? delay : (delay === null || delay === void 0 ? void 0 : delay.hide) || 1000;
    /**
     * Keep showing the tooltip if mouse enters the content area, if there
     * is a `hideDelay` value set, we also start the timeout. The timeout
     * itself does not hide the tooltip, for that we wait until the mouse
     * leaves the content area (see `handleTooltipContentMouseLeave` below).
     */
    const handleTooltipContentMouseEnter = React.useCallback(() => {
        setShouldShow(true);
        setIsMouseOverTooltip(true);
    }, []);
    /**
     * Stops showing the tooltip when mouse leaves the content area, while
     * respecting the current `hideDelay` prop value.
     */
    const handleTooltipContentMouseLeave = React.useCallback(() => {
        setIsMouseOverTooltip(false);
    }, []);
    // Show/hide the tooltip while
    // accounting for the configured delay.
    React.useEffect(() => {
        let showTimeout;
        let hideTimeout;
        if (inProp && !shouldShow) {
            if (showDelay)
                showTimeout = window.setTimeout(() => setShouldShow(true), showDelay);
            else
                setShouldShow(true);
        }
        else if (!inProp && (!waitForPointerExit ? true : !isMouseOverTooltip) && shouldShow) {
            if (hideDelay)
                hideTimeout = window.setTimeout(() => setShouldShow(false), hideDelay);
            else
                setShouldShow(false);
        }
        return () => {
            if (showTimeout)
                clearTimeout(showTimeout);
            if (hideTimeout)
                clearTimeout(hideTimeout);
        };
    }, [inProp, shouldShow, isMouseOverTooltip, showDelay, hideDelay]);
    const anchor = (_a = React__default["default"].Children.map(children, (child) => {
        if (React__default["default"].isValidElement(child) && child.type === TooltipAnchor) {
            return child;
        }
        return null;
    })) === null || _a === void 0 ? void 0 : _a.filter(Boolean);
    const content = (_b = React__default["default"].Children.map(children, (child) => {
        if (React__default["default"].isValidElement(child) && child.type === TooltipContent) {
            return React__default["default"].cloneElement(child, mergeProps.mergeProps(child.props, {
                onMouseEnter: handleTooltipContentMouseEnter,
                onMouseLeave: handleTooltipContentMouseLeave,
            }));
        }
        return null;
    })) === null || _b === void 0 ? void 0 : _b.filter(Boolean);
    // Validate that only one <Tooltip.Anchor> is received.
    const numAnchors = React__default["default"].Children.count(anchor);
    if (numAnchors > 1) {
        throw exceptions.createErrorWithCode('TOOLTIP_ONLY_ONE_ANCHOR_ALLOWED', TooltipBase, `Only one <Tooltip.Anchor> element can be rendered in a <Tooltip> at a time. Received: ${numAnchors}`);
    }
    // Validate that only one <Tooltip.Content> is received.
    const numContents = React__default["default"].Children.count(content);
    if (numContents > 1) {
        throw exceptions.createErrorWithCode('TOOLTIP_ONLY_ONE_CONTENT_ALLOWED', TooltipBase, `Only one <Tooltip.Content> element can be rendered in a <Tooltip> at a time. Received: ${numContents}`);
    }
    if (React__default["default"].Children.count(children) > numAnchors + numContents) {
        // Validate that only <Tooltip.Content> and <Tooltip.Anchor> components are received as children.
        throw exceptions.createErrorWithCode('TOOLTIP_INCOMPATIBLE_CHILDREN_DETECTED', TooltipBase, 'Only children wrapped with <Tooltip.Anchor> or <Tooltip.Content> are allowed within a <Tooltip>.');
    }
    return (React__default["default"].createElement(popover.Popover, Object.assign({ in: shouldShow }, otherProps, { ref: externalRef }),
        React__default["default"].createElement(popover.Popover.Anchor, null, anchor),
        React__default["default"].createElement(popover.Popover.Content, null, content)));
});
const TooltipAnchor = /* @__PURE__ */ forwardRefWrapper.forwardRefWrapper('Tooltip.Anchor', (props, externalRef) => React__default["default"].createElement("div", Object.assign({}, props, { ref: externalRef })));
const TooltipContent = /* @__PURE__ */ forwardRefWrapper.forwardRefWrapper('Tooltip.Content', (props, externalRef) => React__default["default"].createElement("div", Object.assign({}, props, { ref: externalRef })));
const Tooltip = /* @__PURE__ */ Object.assign(TooltipBase, { Anchor: TooltipAnchor, Content: TooltipContent });

exports.Tooltip = Tooltip;
//# sourceMappingURL=tooltip.js.map
