'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../../_virtual/_tslib.js');
var React = require('react');
var reactAria = require('react-aria');
var usableReact = require('usable-react');
var exceptions = require('../../../libs/exceptions.js');
var forwardRefWrapper = require('../../../libs/forward-ref-wrapper.js');
var mergeProps = require('../../../libs/merge-props.js');
var ssrProvider = require('../../ssr-provider.js');
var tooltip = require('./tooltip.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

const HoverActivatedTooltipBase = /* @__PURE__ */ forwardRefWrapper.forwardRefWrapper('HoverActivatedTooltip', (props, externalRef) => {
    var _a, _b;
    const { children } = props, otherProps = _tslib.__rest(props, ["children"]);
    const [focusWithin, setFocusWithinState] = React.useState(false);
    const [hover, setHoverState] = React.useState(false);
    const [showTooltip, setShowTooltip] = React.useState(false);
    const anchorRef = React.useRef(null);
    const contentRef = React.useRef(null);
    const { isServer } = ssrProvider.useSSR();
    if (!isServer) {
        usableReact.useClickOutside([contentRef.current, anchorRef.current], () => setShowTooltip(false), []);
    }
    const { isFocusVisible } = reactAria.useFocusVisible();
    const { focusWithinProps } = reactAria.useFocusWithin({
        onFocusWithinChange: React.useCallback((isFocused) => {
            // In some edge cases, such as when `useClipboard` is in use, document
            // focus may be "stolen away" momentarily. For this case, if keyboard
            // focus is still visible (via `isFocusVisible`), but the active
            // element is `document.body`, then we ignore the blur event and
            // persist the focused tooltip state.
            const isDocumentBodyActive = document.activeElement !== document.body;
            setFocusWithinState(isFocusVisible && (isFocused || isDocumentBodyActive));
        }, [isFocusVisible]),
    });
    const { hoverProps } = reactAria.useHover({
        onHoverChange: React.useCallback((isHovered) => setHoverState(isHovered), []),
    });
    const anchorEvents = React.useMemo(() => {
        return {
            onMouseEnter: () => setShowTooltip(true),
            onTouchStart: () => setShowTooltip(true),
            onMouseLeave: () => setShowTooltip(false),
            onTouchEnd: () => setShowTooltip(false),
        };
    }, [showTooltip]);
    React.useEffect(() => {
        setShowTooltip(focusWithin || hover);
    }, [focusWithin, hover]);
    const anchor = (_a = React__default["default"].Children.map(children, (child) => {
        if (React__default["default"].isValidElement(child) && child.type === HoverActivatedTooltipAnchor) {
            return child;
        }
        return null;
    })) === null || _a === void 0 ? void 0 : _a.filter(Boolean);
    const content = (_b = React__default["default"].Children.map(children, (child) => {
        if (React__default["default"].isValidElement(child) && child.type === HoverActivatedTooltipContent) {
            return child;
        }
        return null;
    })) === null || _b === void 0 ? void 0 : _b.filter(Boolean);
    // Validate that only one <HoverActivatedTooltip.Anchor> is received.
    const numAnchors = React__default["default"].Children.count(anchor);
    if (numAnchors > 1) {
        throw exceptions.createErrorWithCode('HOVER_ACTIVATED_TOOLTIP_ONLY_ONE_ANCHOR_ALLOWED', HoverActivatedTooltipBase, `Only one <HoverActivatedTooltip.Anchor> element can be rendered in a <HoverActivatedTooltip> at a time. Received: ${numAnchors}`);
    }
    // Validate that only one <HoverActivatedTooltip.Content> is received.
    const numContents = React__default["default"].Children.count(content);
    if (numContents > 1) {
        throw exceptions.createErrorWithCode('HOVER_ACTIVATED_TOOLTIP_ONLY_ONE_CONTENT_ALLOWED', HoverActivatedTooltipBase, `Only one <HoverActivatedTooltip.Content> element can be rendered in a <HoverActivatedTooltip> at a time. Received: ${numContents}`);
    }
    if (React__default["default"].Children.count(children) > numAnchors + numContents) {
        // Validate that only <HoverActivatedTooltip.Content> and <HoverActivatedTooltip.Anchor> components are received as children.
        throw exceptions.createErrorWithCode('TOOLTIP_INCOMPATIBLE_CHILDREN_DETECTED', HoverActivatedTooltipBase, 'Only children wrapped with <HoverActivatedTooltip.Anchor> or <HoverActivatedTooltip.Content> are allowed within a <HoverActivatedTooltip>.');
    }
    return (React__default["default"].createElement(tooltip.Tooltip, Object.assign({ in: showTooltip, delay: 0 }, otherProps, { ref: externalRef }),
        React__default["default"].createElement(tooltip.Tooltip.Anchor, Object.assign({}, mergeProps.mergeProps(anchorEvents, focusWithinProps, hoverProps), { ref: anchorRef }), anchor),
        React__default["default"].createElement(tooltip.Tooltip.Content, { ref: contentRef }, content)));
});
const HoverActivatedTooltipAnchor = /* @__PURE__ */ forwardRefWrapper.forwardRefWrapper('HoverActivatedTooltip.Anchor', (props, externalRef) => React__default["default"].createElement("div", Object.assign({}, props, { ref: externalRef })));
const HoverActivatedTooltipContent = /* @__PURE__ */ forwardRefWrapper.forwardRefWrapper('HoverActivatedTooltip.Content', (props, externalRef) => React__default["default"].createElement("div", Object.assign({}, props, { ref: externalRef })));
const HoverActivatedTooltip = /* @__PURE__ */ Object.assign(HoverActivatedTooltipBase, {
    Anchor: HoverActivatedTooltipAnchor,
    Content: HoverActivatedTooltipContent,
});

exports.HoverActivatedTooltip = HoverActivatedTooltip;
//# sourceMappingURL=hover-activated-tooltip.js.map
