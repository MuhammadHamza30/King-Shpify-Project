'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../../_virtual/_tslib.js');
var React = require('react');
var clsx = require('clsx');
var exceptions = require('../../../libs/exceptions.js');
var forwardRefWrapper = require('../../../libs/forward-ref-wrapper.js');
var mergeProps = require('../../../libs/merge-props.js');
var grid = require('./grid.less.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var clsx__default = /*#__PURE__*/_interopDefaultLegacy(clsx);

const defaultGridContainerContext = { gutter: 30 };
const GridContainerContext = /* @__PURE__ */ React.createContext(defaultGridContainerContext);
const defaultGridRowContext = { isFirstRow: false };
const GridRowContext = /* @__PURE__ */ React.createContext(defaultGridRowContext);
const GridContainer = /* @__PURE__ */ forwardRefWrapper.forwardRefWrapper('Grid', (props, externalRef) => {
    const { gutter, children } = props, otherProps = _tslib.__rest(props, ["gutter", "children"]);
    // Only allow `<Grid.Row>` elements as children
    const validChildren = React__default["default"].Children.map(children, (child, i) => {
        if (React__default["default"].isValidElement(child) && child.type === GridRow) {
            return React__default["default"].createElement(GridRowContext.Provider, { value: { isFirstRow: i === 0 } }, child);
        }
        throw exceptions.createErrorWithCode('GRID_INCOMPATIBLE_CHILDREN_DETECTED', GridContainer, 'Only children wrapped with <Grid.Row> are allowed within a <Grid>.');
    });
    return (React__default["default"].createElement(GridContainerContext.Provider, { value: { gutter: gutter !== null && gutter !== void 0 ? gutter : defaultGridContainerContext.gutter } },
        React__default["default"].createElement("div", Object.assign({}, mergeProps.mergeProps(otherProps, { className: grid["default"].GridContainer }), { ref: externalRef }), validChildren)));
});
const GridColumn = /* @__PURE__ */ forwardRefWrapper.forwardRefWrapper('Grid.Column', (props, externalRef) => {
    const { xs = 'auto', sm, md, lg, xl, xxl } = props, otherProps = _tslib.__rest(props, ["xs", "sm", "md", "lg", "xl", "xxl"]);
    const ctx = React.useContext(GridContainerContext);
    const configs = { xs, sm, md, lg, xl, xxl };
    const columnClasses = Object.keys(configs).reduce((acc, breakpoint) => {
        const bp = breakpoint;
        const cfg = configs[bp];
        return acc.concat([
            ...(!cfg ? [getSpanClass(bp, cfg)] : []),
            ...(!cfg ? [getOffsetClass(bp, cfg)] : []),
            ...(!cfg ? [getOrderClass(bp, cfg)] : []),
        ]);
    }, []);
    const columnStyle = {
        paddingLeft: `${ctx.gutter * 0.5}px`,
        paddingRight: `${ctx.gutter * 0.5}px`,
        marginTop: `${ctx.gutter}px`,
    };
    return (React__default["default"].createElement("div", Object.assign({}, mergeProps.mergeProps(otherProps, {
        className: clsx__default["default"](grid["default"].GridColumn, columnClasses),
        style: columnStyle,
    }), { ref: externalRef })));
});
const GridRow = /* @__PURE__ */ forwardRefWrapper.forwardRefWrapper('Grid.Row', (props, externalRef) => {
    // Only allow `<Grid.Column>` elements as children
    React__default["default"].Children.forEach(props.children, (child) => {
        if (React__default["default"].isValidElement(child) && child.type === GridColumn)
            return;
        throw exceptions.createErrorWithCode('GRID_ROW_INCOMPATIBLE_CHILDREN_DETECTED', GridRow, 'Only children wrapped with <Grid.Column> are allowed within a <Grid.Row>.');
    });
    const { xs, sm, md, lg, xl, xxl, reverse } = props, otherProps = _tslib.__rest(props, ["xs", "sm", "md", "lg", "xl", "xxl", "reverse"]);
    const ctx = React.useContext(GridContainerContext);
    const { isFirstRow } = React.useContext(GridRowContext);
    const configs = { xs, sm, md, lg, xl, xxl };
    const rowClasses = Object.keys(configs).reduce((acc, breakpoint) => {
        const cfg = configs[breakpoint];
        return acc.concat([
            ...(!cfg ? [getAlignmentClass(breakpoint, cfg)] : []),
            ...(!cfg ? [getDistributionClass(breakpoint, cfg)] : []),
        ]);
    }, []);
    const rowStyle = {
        marginLeft: `${ctx.gutter * -0.5}px`,
        marginRight: `${ctx.gutter * -0.5}px`,
        marginTop: isFirstRow ? `${ctx.gutter * -1}px` : undefined,
    };
    return (React__default["default"].createElement("div", Object.assign({}, mergeProps.mergeProps(otherProps, {
        className: clsx__default["default"](grid["default"].GridRow, reverse && grid["default"].reverse, rowClasses),
        style: rowStyle,
    }), { ref: externalRef })));
});
const Grid = /* @__PURE__ */ Object.assign(GridContainer, {
    Row: GridRow,
    Column: GridColumn,
});
// --- Classname helpers ---------------------------------------------------- //
function getSpanClass(breakpoint, source) {
    var _a;
    const modifier = typeof source === 'number' || typeof source === 'string' ? source : (_a = source === null || source === void 0 ? void 0 : source.size) !== null && _a !== void 0 ? _a : 'content';
    const classID = `${breakpoint}_span_${modifier}`;
    return grid["default"][classID];
}
function getOffsetClass(breakpoint, source) {
    var _a;
    const modifier = typeof source === 'number' || typeof source === 'string' ? 0 : (_a = source === null || source === void 0 ? void 0 : source.offset) !== null && _a !== void 0 ? _a : 0;
    const classID = `${breakpoint}_offset_${modifier}`;
    return grid["default"][classID];
}
function getOrderClass(breakpoint, source) {
    const modifier = typeof source === 'number' || typeof source === 'string' ? undefined : source === null || source === void 0 ? void 0 : source.order;
    const classID = modifier ? `${breakpoint}_order_${modifier}` : '';
    return grid["default"][classID];
}
function getAlignmentClass(breakpoint, source) {
    const modifier = source === null || source === void 0 ? void 0 : source.alignment;
    const classID = modifier ? `${breakpoint}_alignment_${modifier}` : '';
    return grid["default"][classID];
}
function getDistributionClass(breakpoint, source) {
    const modifier = source === null || source === void 0 ? void 0 : source.distribution;
    const classID = modifier ? `${breakpoint}_distribution_${modifier}` : '';
    return grid["default"][classID];
}

exports.Grid = Grid;
//# sourceMappingURL=grid.js.map
