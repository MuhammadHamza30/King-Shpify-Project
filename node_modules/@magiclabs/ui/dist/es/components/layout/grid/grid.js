import { __rest } from '../../../_virtual/_tslib.js';
import React, { useContext, createContext } from 'react';
import clsx from 'clsx';
import { createErrorWithCode } from '../../../libs/exceptions.js';
import { forwardRefWrapper } from '../../../libs/forward-ref-wrapper.js';
import { mergeProps } from '../../../libs/merge-props.js';
import modules_6b73c699 from './grid.less.js';

const defaultGridContainerContext = { gutter: 30 };
const GridContainerContext = /* @__PURE__ */ createContext(defaultGridContainerContext);
const defaultGridRowContext = { isFirstRow: false };
const GridRowContext = /* @__PURE__ */ createContext(defaultGridRowContext);
const GridContainer = /* @__PURE__ */ forwardRefWrapper('Grid', (props, externalRef) => {
    const { gutter, children } = props, otherProps = __rest(props, ["gutter", "children"]);
    // Only allow `<Grid.Row>` elements as children
    const validChildren = React.Children.map(children, (child, i) => {
        if (React.isValidElement(child) && child.type === GridRow) {
            return React.createElement(GridRowContext.Provider, { value: { isFirstRow: i === 0 } }, child);
        }
        throw createErrorWithCode('GRID_INCOMPATIBLE_CHILDREN_DETECTED', GridContainer, 'Only children wrapped with <Grid.Row> are allowed within a <Grid>.');
    });
    return (React.createElement(GridContainerContext.Provider, { value: { gutter: gutter !== null && gutter !== void 0 ? gutter : defaultGridContainerContext.gutter } },
        React.createElement("div", Object.assign({}, mergeProps(otherProps, { className: modules_6b73c699.GridContainer }), { ref: externalRef }), validChildren)));
});
const GridColumn = /* @__PURE__ */ forwardRefWrapper('Grid.Column', (props, externalRef) => {
    const { xs = 'auto', sm, md, lg, xl, xxl } = props, otherProps = __rest(props, ["xs", "sm", "md", "lg", "xl", "xxl"]);
    const ctx = useContext(GridContainerContext);
    const configs = { xs, sm, md, lg, xl, xxl };
    const columnClasses = Object.keys(configs).reduce((acc, breakpoint) => {
        const bp = breakpoint;
        const cfg = configs[bp];
        return acc.concat([
            ...(!cfg ? [getSpanClass(bp, cfg)] : []),
            ...(!cfg ? [getOffsetClass(bp, cfg)] : []),
            ...(!cfg ? [getOrderClass(bp, cfg)] : []),
        ]);
    }, []);
    const columnStyle = {
        paddingLeft: `${ctx.gutter * 0.5}px`,
        paddingRight: `${ctx.gutter * 0.5}px`,
        marginTop: `${ctx.gutter}px`,
    };
    return (React.createElement("div", Object.assign({}, mergeProps(otherProps, {
        className: clsx(modules_6b73c699.GridColumn, columnClasses),
        style: columnStyle,
    }), { ref: externalRef })));
});
const GridRow = /* @__PURE__ */ forwardRefWrapper('Grid.Row', (props, externalRef) => {
    // Only allow `<Grid.Column>` elements as children
    React.Children.forEach(props.children, (child) => {
        if (React.isValidElement(child) && child.type === GridColumn)
            return;
        throw createErrorWithCode('GRID_ROW_INCOMPATIBLE_CHILDREN_DETECTED', GridRow, 'Only children wrapped with <Grid.Column> are allowed within a <Grid.Row>.');
    });
    const { xs, sm, md, lg, xl, xxl, reverse } = props, otherProps = __rest(props, ["xs", "sm", "md", "lg", "xl", "xxl", "reverse"]);
    const ctx = useContext(GridContainerContext);
    const { isFirstRow } = useContext(GridRowContext);
    const configs = { xs, sm, md, lg, xl, xxl };
    const rowClasses = Object.keys(configs).reduce((acc, breakpoint) => {
        const cfg = configs[breakpoint];
        return acc.concat([
            ...(!cfg ? [getAlignmentClass(breakpoint, cfg)] : []),
            ...(!cfg ? [getDistributionClass(breakpoint, cfg)] : []),
        ]);
    }, []);
    const rowStyle = {
        marginLeft: `${ctx.gutter * -0.5}px`,
        marginRight: `${ctx.gutter * -0.5}px`,
        marginTop: isFirstRow ? `${ctx.gutter * -1}px` : undefined,
    };
    return (React.createElement("div", Object.assign({}, mergeProps(otherProps, {
        className: clsx(modules_6b73c699.GridRow, reverse && modules_6b73c699.reverse, rowClasses),
        style: rowStyle,
    }), { ref: externalRef })));
});
const Grid = /* @__PURE__ */ Object.assign(GridContainer, {
    Row: GridRow,
    Column: GridColumn,
});
// --- Classname helpers ---------------------------------------------------- //
function getSpanClass(breakpoint, source) {
    var _a;
    const modifier = typeof source === 'number' || typeof source === 'string' ? source : (_a = source === null || source === void 0 ? void 0 : source.size) !== null && _a !== void 0 ? _a : 'content';
    const classID = `${breakpoint}_span_${modifier}`;
    return modules_6b73c699[classID];
}
function getOffsetClass(breakpoint, source) {
    var _a;
    const modifier = typeof source === 'number' || typeof source === 'string' ? 0 : (_a = source === null || source === void 0 ? void 0 : source.offset) !== null && _a !== void 0 ? _a : 0;
    const classID = `${breakpoint}_offset_${modifier}`;
    return modules_6b73c699[classID];
}
function getOrderClass(breakpoint, source) {
    const modifier = typeof source === 'number' || typeof source === 'string' ? undefined : source === null || source === void 0 ? void 0 : source.order;
    const classID = modifier ? `${breakpoint}_order_${modifier}` : '';
    return modules_6b73c699[classID];
}
function getAlignmentClass(breakpoint, source) {
    const modifier = source === null || source === void 0 ? void 0 : source.alignment;
    const classID = modifier ? `${breakpoint}_alignment_${modifier}` : '';
    return modules_6b73c699[classID];
}
function getDistributionClass(breakpoint, source) {
    const modifier = source === null || source === void 0 ? void 0 : source.distribution;
    const classID = modifier ? `${breakpoint}_distribution_${modifier}` : '';
    return modules_6b73c699[classID];
}

export { Grid };
//# sourceMappingURL=grid.js.map
