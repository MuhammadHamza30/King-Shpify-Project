import { __awaiter, __rest } from '../../_virtual/_tslib.js';
import composeRefs from '@seznam/compose-react-refs';
import React, { useRef, useState, useCallback, useEffect } from 'react';
import { useIsMounted } from 'usable-react';
import { watchResize } from 'watch-resize';
import { cssTimeToMilliseconds } from '../../libs/css-time-to-milliseconds.js';
import { forwardRefWrapper } from '../../libs/forward-ref-wrapper.js';
import { useSSR } from '../ssr-provider.js';

/**
 * This component is a container which automatically updates its `height` and
 * `width` styles property based on the total size of its child nodes. This
 * enables dynamic transitional height behavior.
 */
const AutoResizingDiv = /* @__PURE__ */ forwardRefWrapper('AutoResizingDiv', {
    initialDelay: 0,
    transition: true,
    applyCSSVariables: {},
    onResize: () => { },
    style: {},
    observerOnly: false,
    autoWidth: false,
    autoHeight: false,
}, (props, externalRef) => {
    // --- Data
    var _a, _b, _c, _d;
    const contentElement = useRef();
    const [height, setHeight] = useState('auto');
    const [width, setWidth] = useState('auto');
    const { isClient } = useSSR();
    const isMounted = useIsMounted();
    const isTransitioning = useRef(false);
    const raf = useRef(null);
    // --- Utilities for handling `watch-resize` observer
    /**
     * Set the `containerElement` ref height based on the given element
     * or `contentElement` ref as a fallback.
     */
    const setContainerElementDimensions = useCallback((domRect) => {
        let rect = domRect;
        if (!rect) {
            if (contentElement.current)
                rect = contentElement.current.getBoundingClientRect();
            else
                return;
        }
        if (!props.autoHeight) {
            const nextHeight = Math.ceil(rect.height);
            if (nextHeight !== height && isMounted())
                setHeight(`${nextHeight}px`);
        }
        if (!props.autoWidth) {
            const nextWidth = Math.ceil(rect.width);
            if (nextWidth !== width && isMounted())
                setWidth(`${nextWidth}px`);
        }
    }, [height, width]);
    /**
     * Build styles to transition height.
     */
    const createTransitionStyles = useCallback((heightOverride, widthOverride) => {
        if (props.transition) {
            let transition = 'height 0.2s ease, width 0.2s ease';
            if (typeof props.transition !== 'boolean') {
                const { duration, timingFunction, delay } = props.transition;
                transition = `height${duration ? `${duration} ` : ' 0.2s'}${timingFunction ? `${timingFunction} ` : ' ease'}${delay ? `${delay} ` : ' 0s'}`;
                transition += `, width${duration ? `${duration} ` : ' 0.2s'}${timingFunction ? `${timingFunction} ` : ' ease'}${delay ? `${delay} ` : ' 0s'}`;
            }
            const heightOverrideAsPxMeasurement = heightOverride ? `${Math.ceil(heightOverride)}px` : null;
            const heightAsPxMeasurement = typeof height === 'string' ? height : `${Math.ceil(height)}px`;
            const widthOverrideAsPxMeasurement = widthOverride ? `${Math.ceil(widthOverride)}px` : null;
            const widthAsPxMeasurement = typeof width === 'string' ? width : `${Math.ceil(width)}px`;
            return {
                transition,
                height: props.autoHeight ? 'auto' : heightOverrideAsPxMeasurement || heightAsPxMeasurement,
                width: props.autoWidth ? 'auto' : widthOverrideAsPxMeasurement || widthAsPxMeasurement,
                willChange: 'height, width',
            };
        }
        return {
            transition: 'none',
            height: 'auto',
            width: 'auto',
            willChange: 'unset',
        };
    }, [props.transition, height, width]);
    /**
     * Set CSS variables for the generated `transition` and `height` properties.
     */
    const applyCSSVariables = useCallback((heightOverride, widthOverride) => {
        const { element, heightVar, widthVar, transitionVar } = props.applyCSSVariables;
        const transitionStyles = createTransitionStyles(heightOverride, widthOverride);
        const elementResolved = element || document.documentElement;
        if (heightVar && isMounted()) {
            elementResolved.style.setProperty(heightVar, props.autoHeight ? 'auto' : transitionStyles.height);
        }
        if (widthVar && isMounted()) {
            elementResolved.style.setProperty(widthVar, props.autoWidth ? 'auto' : transitionStyles.width);
        }
        if (transitionVar && isMounted()) {
            elementResolved.style.setProperty(transitionVar, transitionStyles.transition);
        }
    }, [
        (_a = props.applyCSSVariables) === null || _a === void 0 ? void 0 : _a.element,
        (_b = props.applyCSSVariables) === null || _b === void 0 ? void 0 : _b.heightVar,
        (_c = props.applyCSSVariables) === null || _c === void 0 ? void 0 : _c.widthVar,
        (_d = props.applyCSSVariables) === null || _d === void 0 ? void 0 : _d.transitionVar,
    ]);
    /**
     * Create the resize stream and start observing.
     */
    const setupResizeObserver = useCallback(() => __awaiter(void 0, void 0, void 0, function* () {
        /*
          Under the hood, `watchResize` is creating a nested browsing
          context inside a DOM `<object>`. This nested context has a
          `window` object that provides the stream of "resize" events.
         */
        const destroyer = yield watchResize(contentElement.current, (payload) => {
            var _a, _b;
            isTransitioning.current = true;
            setTimeout(() => {
                isTransitioning.current = false;
            }, cssTimeToMilliseconds((_a = props.transition) === null || _a === void 0 ? void 0 : _a.duration) + 100);
            const rect = payload.element.getBoundingClientRect();
            (_b = props.onResize) === null || _b === void 0 ? void 0 : _b.call(props, Object.assign(Object.assign({}, payload), { transitionStyles: createTransitionStyles(rect.height, rect.width) }));
            applyCSSVariables(rect.height, rect.width);
            if (!props.observerOnly)
                setContainerElementDimensions(rect);
        });
        return destroyer;
    }), [
        setContainerElementDimensions,
        props.observerOnly,
        createTransitionStyles,
        applyCSSVariables,
        props.transition,
    ]);
    // --- React lifecycle
    // Setup/teardown the resize observable on component mount/unmount
    useEffect(() => {
        let destroyResizeListener;
        let timeout;
        (() => __awaiter(void 0, void 0, void 0, function* () {
            if (isClient) {
                if (props.initialDelay) {
                    timeout = setTimeout(() => __awaiter(void 0, void 0, void 0, function* () {
                        if (!props.observerOnly)
                            setContainerElementDimensions();
                        destroyResizeListener = yield setupResizeObserver();
                    }), props.initialDelay);
                }
                else {
                    setContainerElementDimensions();
                    destroyResizeListener = yield setupResizeObserver();
                }
            }
        }))();
        return () => {
            if (timeout)
                clearTimeout(timeout);
            if (destroyResizeListener)
                destroyResizeListener();
        };
    }, []);
    useEffect(() => {
        if (isTransitioning.current && props.onAnimationFrame && isClient) {
            const tick = () => {
                raf.current = requestAnimationFrame((...args) => {
                    props.onAnimationFrame(...args);
                    if (isTransitioning.current)
                        tick();
                });
            };
            tick();
        }
        else {
            return () => {
                if (raf.current)
                    cancelAnimationFrame(raf.current);
            };
        }
        return undefined;
    });
    // --- Rendering
    const otherProps = __rest(props, ["children", "style", "initialDelay", "transition", "onResize", "observerOnly", "applyCSSVariables", "onAnimationFrame", "autoWidth", "autoHeight"]);
    return props.observerOnly ? (React.createElement("div", Object.assign({ style: props.style }, otherProps, { ref: composeRefs(contentElement, externalRef) }), props.children)) : (React.createElement("div", Object.assign({ style: Object.assign(Object.assign({ position: 'relative' }, props.style), createTransitionStyles()) }, otherProps),
        React.createElement("div", { ref: composeRefs(contentElement, externalRef), style: { position: width === 'auto' ? undefined : 'absolute' } }, props.children)));
});

export { AutoResizingDiv };
//# sourceMappingURL=auto-resizing-div.js.map
