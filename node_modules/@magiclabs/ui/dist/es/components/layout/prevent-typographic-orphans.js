import React, { useRef } from 'react';
import { useForceUpdate, useEffectAfterMount } from 'usable-react';
import { useIsomorphicLayoutEffect } from '../../hooks/use-isomorphic-layout-effect.js';

const DEFAULT_TEXT_TAGS = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'figcaption'];
const DEFAULT_WORD_COUNT_THRESHOLD = 4;
/**
 * Automatically injects non-breaking spaces between the last
 * two words of a text block to prevent typographic orphans.
 */
const PreventTypographicOrphans = (props) => {
    const { children, wordCountThreshold = DEFAULT_WORD_COUNT_THRESHOLD, tags = DEFAULT_TEXT_TAGS } = props;
    const ref = useRef(null);
    const forceUpdate = useForceUpdate();
    // Apply fixes on initial render.
    useIsomorphicLayoutEffect(() => {
        applyTypographyFixes(ref.current, tags, wordCountThreshold);
    }, []);
    // Apply fixes on subsequent renders where the DOM tree has changed.
    useEffectAfterMount(() => {
        if (ref.current) {
            const observer = new MutationObserver((mutations, obs) => {
                obs.disconnect();
                const uniqueTargets = [...new Set(mutations.map((mut) => mut.target))];
                applyTypographyFixes(ref.current, tags, wordCountThreshold, uniqueTargets);
                forceUpdate();
            });
            observer.observe(ref.current, {
                characterData: true,
                attributes: false,
                childList: true,
                subtree: true,
            });
            return () => observer.disconnect();
        }
        return undefined;
    });
    return React.createElement("div", { ref: ref }, children);
};
/**
 * Gathers text nodes from the given parent element,
 * checks if orphan control should be applied,
 * then applies the fixes.
 */
function applyTypographyFixes(parentNode, tags, wordCountThreshold, targets) {
    if (!parentNode)
        return;
    const elems = parentNode.querySelectorAll(tags.join(', '));
    elems.forEach((elem) => {
        if (shouldPreventOrphansCheck(elem, wordCountThreshold, targets)) {
            preventOrphans(elem);
        }
    });
}
/**
 * Applies fixes to prevent typographic orphans in the given element.
 */
function preventOrphans(elem) {
    var _a, _b, _c;
    const reduceFlattenedTextNodes = (acc, node) => {
        switch (node.nodeType) {
            case Node.ELEMENT_NODE:
                return [...acc, ...Array.from(node.childNodes).reduce(reduceFlattenedTextNodes, [])];
            case Node.TEXT_NODE:
            default:
                return [...acc, node];
        }
    };
    const flattenedTextNodes = Array.from(elem.childNodes)
        .reduce(reduceFlattenedTextNodes, [])
        .filter((node) => { var _a; return !!node.nodeValue && !!((_a = node.nodeValue) === null || _a === void 0 ? void 0 : _a.length); })
        .reverse();
    const targetIndex = (_b = (_a = getTextItems(elem.innerText).pop()) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
    let indexCounter = 0;
    const targetTextNode = flattenedTextNodes.find((node) => {
        var _a, _b;
        indexCounter += (_b = (_a = node.nodeValue) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
        return indexCounter >= targetIndex;
    });
    if (targetTextNode === null || targetTextNode === void 0 ? void 0 : targetTextNode.parentElement) {
        const textItems = getTextItems(targetTextNode.nodeValue);
        // Target the last word
        const targetWord = textItems[textItems.length - 1];
        // Prefix with a non-breaking space
        textItems[textItems.length - 1] = `\u{00A0}${targetWord}`;
        // Join the words back together.
        // We `pop` the last word from `textItems` to avoid joining the result with
        // an obsolete whitespace character.
        const lastWord = textItems.pop();
        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
        const result = textItems.join(' ') + lastWord;
        targetTextNode.parentElement.replaceChild(new Text(result), targetTextNode);
        // When this condition is true, the target text node had no whitespace
        // character contained within it (we added it above). So, we'll need to make
        // sure we trim a whitespace character from the end of the preceding text node.
        if ((lastWord === null || lastWord === void 0 ? void 0 : lastWord.length) === targetTextNode.nodeValue.length + 1) {
            // Capture the text node before the target text node. (we add 1 to the index to account for the reversed array).
            // We'll need to trim a trailing space from this node if one exists.
            const precedingTextNode = flattenedTextNodes[flattenedTextNodes.findIndex((node) => node === targetTextNode) + 1];
            if (precedingTextNode === null || precedingTextNode === void 0 ? void 0 : precedingTextNode.parentElement) {
                // const textItems = getTextItems(precedingTextNode.nodeValue!);
                if ((_c = [...precedingTextNode.nodeValue].pop()) === null || _c === void 0 ? void 0 : _c.match(/\s/)) {
                    // eslint-disable-next-line no-shadow
                    const result = precedingTextNode.nodeValue.slice(0, -1);
                    precedingTextNode.parentElement.replaceChild(new Text(result), precedingTextNode);
                }
            }
        }
    }
}
/**
 * Returns `true` if the text block contains
 * at least `wordCountThreshold` words.
 */
function shouldPreventOrphansCheck(elem, wordCountThreshold, targets) {
    const passesWordCountThreshold = getTextItems(elem.innerText).length >= wordCountThreshold;
    const elemContainsSomeTargets = targets == null ? true : targets.some((node) => elem.contains(node));
    return passesWordCountThreshold && elemContainsSomeTargets;
}
function getTextItems(text) {
    return text.replace(/\u00A0/g, ' ').split(/\s/);
}

export { PreventTypographicOrphans };
//# sourceMappingURL=prevent-typographic-orphans.js.map
