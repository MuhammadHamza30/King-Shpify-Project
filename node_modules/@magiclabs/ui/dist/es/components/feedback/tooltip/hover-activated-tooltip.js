import { __rest } from '../../../_virtual/_tslib.js';
import React, { useState, useRef, useCallback, useMemo, useEffect } from 'react';
import { useFocusVisible, useFocusWithin, useHover } from 'react-aria';
import { useClickOutside } from 'usable-react';
import { createErrorWithCode } from '../../../libs/exceptions.js';
import { forwardRefWrapper } from '../../../libs/forward-ref-wrapper.js';
import { mergeProps } from '../../../libs/merge-props.js';
import { useSSR } from '../../ssr-provider.js';
import { Tooltip } from './tooltip.js';

const HoverActivatedTooltipBase = /* @__PURE__ */ forwardRefWrapper('HoverActivatedTooltip', (props, externalRef) => {
    var _a, _b;
    const { children } = props, otherProps = __rest(props, ["children"]);
    const [focusWithin, setFocusWithinState] = useState(false);
    const [hover, setHoverState] = useState(false);
    const [showTooltip, setShowTooltip] = useState(false);
    const anchorRef = useRef(null);
    const contentRef = useRef(null);
    const { isServer } = useSSR();
    if (!isServer) {
        useClickOutside([contentRef.current, anchorRef.current], () => setShowTooltip(false), []);
    }
    const { isFocusVisible } = useFocusVisible();
    const { focusWithinProps } = useFocusWithin({
        onFocusWithinChange: useCallback((isFocused) => {
            // In some edge cases, such as when `useClipboard` is in use, document
            // focus may be "stolen away" momentarily. For this case, if keyboard
            // focus is still visible (via `isFocusVisible`), but the active
            // element is `document.body`, then we ignore the blur event and
            // persist the focused tooltip state.
            const isDocumentBodyActive = document.activeElement !== document.body;
            setFocusWithinState(isFocusVisible && (isFocused || isDocumentBodyActive));
        }, [isFocusVisible]),
    });
    const { hoverProps } = useHover({
        onHoverChange: useCallback((isHovered) => setHoverState(isHovered), []),
    });
    const anchorEvents = useMemo(() => {
        return {
            onMouseEnter: () => setShowTooltip(true),
            onTouchStart: () => setShowTooltip(true),
            onMouseLeave: () => setShowTooltip(false),
            onTouchEnd: () => setShowTooltip(false),
        };
    }, [showTooltip]);
    useEffect(() => {
        setShowTooltip(focusWithin || hover);
    }, [focusWithin, hover]);
    const anchor = (_a = React.Children.map(children, (child) => {
        if (React.isValidElement(child) && child.type === HoverActivatedTooltipAnchor) {
            return child;
        }
        return null;
    })) === null || _a === void 0 ? void 0 : _a.filter(Boolean);
    const content = (_b = React.Children.map(children, (child) => {
        if (React.isValidElement(child) && child.type === HoverActivatedTooltipContent) {
            return child;
        }
        return null;
    })) === null || _b === void 0 ? void 0 : _b.filter(Boolean);
    // Validate that only one <HoverActivatedTooltip.Anchor> is received.
    const numAnchors = React.Children.count(anchor);
    if (numAnchors > 1) {
        throw createErrorWithCode('HOVER_ACTIVATED_TOOLTIP_ONLY_ONE_ANCHOR_ALLOWED', HoverActivatedTooltipBase, `Only one <HoverActivatedTooltip.Anchor> element can be rendered in a <HoverActivatedTooltip> at a time. Received: ${numAnchors}`);
    }
    // Validate that only one <HoverActivatedTooltip.Content> is received.
    const numContents = React.Children.count(content);
    if (numContents > 1) {
        throw createErrorWithCode('HOVER_ACTIVATED_TOOLTIP_ONLY_ONE_CONTENT_ALLOWED', HoverActivatedTooltipBase, `Only one <HoverActivatedTooltip.Content> element can be rendered in a <HoverActivatedTooltip> at a time. Received: ${numContents}`);
    }
    if (React.Children.count(children) > numAnchors + numContents) {
        // Validate that only <HoverActivatedTooltip.Content> and <HoverActivatedTooltip.Anchor> components are received as children.
        throw createErrorWithCode('TOOLTIP_INCOMPATIBLE_CHILDREN_DETECTED', HoverActivatedTooltipBase, 'Only children wrapped with <HoverActivatedTooltip.Anchor> or <HoverActivatedTooltip.Content> are allowed within a <HoverActivatedTooltip>.');
    }
    return (React.createElement(Tooltip, Object.assign({ in: showTooltip, delay: 0 }, otherProps, { ref: externalRef }),
        React.createElement(Tooltip.Anchor, Object.assign({}, mergeProps(anchorEvents, focusWithinProps, hoverProps), { ref: anchorRef }), anchor),
        React.createElement(Tooltip.Content, { ref: contentRef }, content)));
});
const HoverActivatedTooltipAnchor = /* @__PURE__ */ forwardRefWrapper('HoverActivatedTooltip.Anchor', (props, externalRef) => React.createElement("div", Object.assign({}, props, { ref: externalRef })));
const HoverActivatedTooltipContent = /* @__PURE__ */ forwardRefWrapper('HoverActivatedTooltip.Content', (props, externalRef) => React.createElement("div", Object.assign({}, props, { ref: externalRef })));
const HoverActivatedTooltip = /* @__PURE__ */ Object.assign(HoverActivatedTooltipBase, {
    Anchor: HoverActivatedTooltipAnchor,
    Content: HoverActivatedTooltipContent,
});

export { HoverActivatedTooltip };
//# sourceMappingURL=hover-activated-tooltip.js.map
