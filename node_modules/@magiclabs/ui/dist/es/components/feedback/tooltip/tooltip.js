import { __rest } from '../../../_virtual/_tslib.js';
import React, { useState, useCallback, useEffect } from 'react';
import { forwardRefWrapper } from '../../../libs/forward-ref-wrapper.js';
import { mergeProps } from '../../../libs/merge-props.js';
import { createErrorWithCode } from '../../../libs/exceptions.js';
import 'clsx';
import { Popover } from '../../layout/popover/popover.js';
import 'usable-react';
import '@seznam/compose-react-refs';
import 'react-aria';
import 'blueimp-md5';
import 'color';
import '@artsy/fresnel';
import '../../theme-provider/theme-provider.js';
import '../../theme-provider/theme-head.js';
import 'framer-motion';
import 'react-dom';
import '@react-aria/ssr';
import 'watch-resize';

/* eslint-disable no-nested-ternary */
const TooltipBase = /* @__PURE__ */ forwardRefWrapper('Tooltip', {
    delay: 0,
    arrow: true,
    waitForPointerExit: true,
}, (props, externalRef) => {
    var _a, _b;
    const { children, in: inProp, delay, waitForPointerExit } = props, otherProps = __rest(props, ["children", "in", "delay", "waitForPointerExit"]);
    const [shouldShow, setShouldShow] = useState(inProp);
    const [isMouseOverTooltip, setIsMouseOverTooltip] = useState(false);
    const showDelay = typeof delay === 'number' ? delay : (delay === null || delay === void 0 ? void 0 : delay.show) || 0;
    const hideDelay = typeof delay === 'number' ? delay : (delay === null || delay === void 0 ? void 0 : delay.hide) || 1000;
    /**
     * Keep showing the tooltip if mouse enters the content area, if there
     * is a `hideDelay` value set, we also start the timeout. The timeout
     * itself does not hide the tooltip, for that we wait until the mouse
     * leaves the content area (see `handleTooltipContentMouseLeave` below).
     */
    const handleTooltipContentMouseEnter = useCallback(() => {
        setShouldShow(true);
        setIsMouseOverTooltip(true);
    }, []);
    /**
     * Stops showing the tooltip when mouse leaves the content area, while
     * respecting the current `hideDelay` prop value.
     */
    const handleTooltipContentMouseLeave = useCallback(() => {
        setIsMouseOverTooltip(false);
    }, []);
    // Show/hide the tooltip while
    // accounting for the configured delay.
    useEffect(() => {
        let showTimeout;
        let hideTimeout;
        if (inProp && !shouldShow) {
            if (showDelay)
                showTimeout = window.setTimeout(() => setShouldShow(true), showDelay);
            else
                setShouldShow(true);
        }
        else if (!inProp && (!waitForPointerExit ? true : !isMouseOverTooltip) && shouldShow) {
            if (hideDelay)
                hideTimeout = window.setTimeout(() => setShouldShow(false), hideDelay);
            else
                setShouldShow(false);
        }
        return () => {
            if (showTimeout)
                clearTimeout(showTimeout);
            if (hideTimeout)
                clearTimeout(hideTimeout);
        };
    }, [inProp, shouldShow, isMouseOverTooltip, showDelay, hideDelay]);
    const anchor = (_a = React.Children.map(children, (child) => {
        if (React.isValidElement(child) && child.type === TooltipAnchor) {
            return child;
        }
        return null;
    })) === null || _a === void 0 ? void 0 : _a.filter(Boolean);
    const content = (_b = React.Children.map(children, (child) => {
        if (React.isValidElement(child) && child.type === TooltipContent) {
            return React.cloneElement(child, mergeProps(child.props, {
                onMouseEnter: handleTooltipContentMouseEnter,
                onMouseLeave: handleTooltipContentMouseLeave,
            }));
        }
        return null;
    })) === null || _b === void 0 ? void 0 : _b.filter(Boolean);
    // Validate that only one <Tooltip.Anchor> is received.
    const numAnchors = React.Children.count(anchor);
    if (numAnchors > 1) {
        throw createErrorWithCode('TOOLTIP_ONLY_ONE_ANCHOR_ALLOWED', TooltipBase, `Only one <Tooltip.Anchor> element can be rendered in a <Tooltip> at a time. Received: ${numAnchors}`);
    }
    // Validate that only one <Tooltip.Content> is received.
    const numContents = React.Children.count(content);
    if (numContents > 1) {
        throw createErrorWithCode('TOOLTIP_ONLY_ONE_CONTENT_ALLOWED', TooltipBase, `Only one <Tooltip.Content> element can be rendered in a <Tooltip> at a time. Received: ${numContents}`);
    }
    if (React.Children.count(children) > numAnchors + numContents) {
        // Validate that only <Tooltip.Content> and <Tooltip.Anchor> components are received as children.
        throw createErrorWithCode('TOOLTIP_INCOMPATIBLE_CHILDREN_DETECTED', TooltipBase, 'Only children wrapped with <Tooltip.Anchor> or <Tooltip.Content> are allowed within a <Tooltip>.');
    }
    return (React.createElement(Popover, Object.assign({ in: shouldShow }, otherProps, { ref: externalRef }),
        React.createElement(Popover.Anchor, null, anchor),
        React.createElement(Popover.Content, null, content)));
});
const TooltipAnchor = /* @__PURE__ */ forwardRefWrapper('Tooltip.Anchor', (props, externalRef) => React.createElement("div", Object.assign({}, props, { ref: externalRef })));
const TooltipContent = /* @__PURE__ */ forwardRefWrapper('Tooltip.Content', (props, externalRef) => React.createElement("div", Object.assign({}, props, { ref: externalRef })));
const Tooltip = /* @__PURE__ */ Object.assign(TooltipBase, { Anchor: TooltipAnchor, Content: TooltipContent });

export { Tooltip };
//# sourceMappingURL=tooltip.js.map
