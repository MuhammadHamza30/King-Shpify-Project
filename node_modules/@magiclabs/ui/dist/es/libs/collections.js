import React from 'react';
import { logWarning, createErrorWithCode } from './exceptions.js';
import { createGenericComponent } from './generic-component.js';

function ItemRender(props) {
    return null;
}
ItemRender.getCollectionNode = function* getCollectionNode(props, context) {
    const { childItems, title, children } = props;
    const rendered = props.title || props.children;
    const textValue = props.textValue || (typeof rendered === 'string' ? rendered : '') || props['aria-label'] || '';
    if (!textValue && !(context === null || context === void 0 ? void 0 : context.suppressTextValueWarning)) {
        logWarning(`<Item>`, 'Non-plain text contents is unsupported by type-to-select for accessibility. Please add a `textValue` prop.');
    }
    yield {
        type: 'item',
        props,
        rendered,
        textValue,
        'aria-label': props['aria-label'],
        hasChildNodes: hasChildItems(props),
        *childNodes() {
            if (childItems) {
                for (const child of childItems) {
                    yield {
                        type: 'item',
                        value: child,
                    };
                }
            }
            else if (title) {
                const items = [];
                React.Children.forEach(children, (child) => {
                    items.push({
                        type: 'item',
                        element: child,
                    });
                });
                yield* items;
            }
        },
    };
};
const Item = /* @__PURE__ */ createGenericComponent('Item', ItemRender);
function SectionRender(props) {
    return null;
}
SectionRender.getCollectionNode = function* getCollectionNode(props) {
    const { children, title, items } = props;
    yield {
        type: 'section',
        hasChildNodes: true,
        rendered: title,
        'aria-label': props['aria-label'],
        *childNodes() {
            if (typeof children === 'function') {
                if (!items) {
                    throw createErrorWithCode('INVALID_COLLECTION_FACTORY_WITHOUT_ITEMS', `<Section>`, '`props.children` is a function but `props.items` is missing.');
                }
                for (const item of items) {
                    yield {
                        type: 'item',
                        value: item,
                        renderer: children,
                    };
                }
            }
            else {
                // eslint-disable-next-line no-shadow
                const items = [];
                React.Children.forEach(children, (child) => {
                    items.push({
                        type: 'item',
                        element: child,
                    });
                });
                yield* items;
            }
        },
    };
};
const Section = /* @__PURE__ */ createGenericComponent('Section', SectionRender);
function hasChildItems(props) {
    if (props.hasChildItems != null) {
        return props.hasChildItems;
    }
    if (props.childItems) {
        return true;
    }
    if (props.title && React.Children.count(props.children) > 0) {
        return true;
    }
    return false;
}
function isValidCollectionChild(source, child) {
    if (React.isValidElement(child) && !!child.type.getCollectionNode)
        return;
    throw createErrorWithCode('INVALID_COLLECTION_INCOMPATIBLE_CHILDREN_DETECTED', source, 'Only children wrapped with <Item> or <Section> are allowed.');
}
/**
 * Performs arbitrary validations upon on a list of `CollectionChildren`. We use
 * this to white-label error messages related to `@react-stately/collections`.
 *
 * Returns a replacement list of `CollectionChildren` with the validations
 * applied. The return value from this function can be given directly to
 * collection-based hooks/components from `@react-stately/collections`.
 */
function validateCollection(props, source) {
    const { children, items } = props;
    if (typeof children !== 'function') {
        React.Children.forEach(children, (child) => {
            isValidCollectionChild(source, child);
        });
        return children;
    }
    if (!items) {
        throw createErrorWithCode('INVALID_COLLECTION_FACTORY_WITHOUT_ITEMS', source, '`props.children` is a function but `props.items` is missing.');
    }
    return (...args) => {
        var _a;
        const element = children === null || children === void 0 ? void 0 : children(...args);
        const key = (_a = element.key) !== null && _a !== void 0 ? _a : element.id;
        if (key == null) {
            throw createErrorWithCode('INVALID_COLLECTION_MISSING_KEY', source, 'No key found for item.');
        }
        isValidCollectionChild(source, element);
        return element;
    };
}

export { Item, Section, validateCollection };
//# sourceMappingURL=collections.js.map
